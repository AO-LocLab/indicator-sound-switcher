#!/usr/bin/env python3
"""
Copyright (C) 2012-2015 Dmitry Kann, http://yktoo.com

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3, as published
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranties of
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# Global definitions
APP_ID      = "indicator-sound-switcher"
APP_NAME    = "Sound Switcher Indicator"
APP_ICON    = "indicator-sound-switcher"
APP_VERSION = "2.0.1"
APP_LICENCE = """This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3, as published
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranties of
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see http://www.gnu.org/licenses/"""

import sys
import logging

from gi import require_version
from gi.repository import GObject

require_version('Gtk', '3.0')
from gi.repository import Gtk

require_version('AppIndicator3', '0.1')
from gi.repository import AppIndicator3 as AppIndicator

from indicator_sound_switcher.lib_pulseaudio import *


YESNO = {False: 'No', True: 'Yes'}


def _parse_cmd_line():
    """Parse command line arguments. Currently only sets up logging."""
    # Check command line arguments
    lvl = logging.WARNING
    for arg in sys.argv:
        if arg == '-v':
            lvl = logging.INFO
            break
        elif arg == '-vv':
            lvl = logging.DEBUG
            break
    # Set up logging options
    logging.basicConfig(level=lvl, format='%(levelname).3s %(message)s')


class SoundSwitcherIndicator(GObject.GObject):

    # ==================================================================================================================
    # Port
    # ==================================================================================================================

    class Port(GObject.GObject):
        """Generic (sink/source) port class."""

        def get_is_active(self):
            """is_active: defines whether the associated port is the active one for its sink/source."""
            return self._is_active

        def set_is_active(self, value: bool):
            self._is_active = value

            # If activated, also activate the item that corresponds to the port
            if self.is_active and self.menu_item:
                # Inhibit the activate event
                with self.menu_item.handler_block(self.handler_id):
                    self.menu_item.set_active(True)

        is_active = GObject.property(type=bool, default=False, getter=get_is_active, setter=set_is_active)

        def get_is_available(self):
            """is_available: defines whether the associated port is the available for the user."""
            return self._is_available or self.is_dummy  # A dummy port is considered "always available"

        def set_is_available(self, value: bool):
            self._is_available = value

            # Show or hide the corresponding menu item
            if self.menu_item:
                if self.is_available:
                    self.menu_item.show()
                else:
                    self.menu_item.hide()

        is_available = GObject.property(type=bool, default=False, getter=get_is_available, setter=set_is_available)

        def __init__(self, name: str, description, priority: int, is_available: bool, direction: int, profiles):
            """Constructor."""
            GObject.GObject.__init__(self)
            self.name          = name
            self.description   = description
            self.priority      = priority
            self._is_available = is_available
            self.direction     = direction
            self.profiles      = profiles

            # Initialise other properties
            self.owner_stream  = None
            self.onwer_card    = None
            self.menu_item     = None
            self._is_active    = False

            # Initialise derived properties
            self.is_dummy  = description is None
            self.is_output = direction == PA_DIRECTION_OUTPUT

            # Activate signal's handler ID (will be used for inhibiting the handler later)
            self.handler_id  = None

        def get_menu_item_title(self):
            """Returns the title to be used with menu item."""
            return \
                (self.owner_card.description if self.owner_card else '(unknown device)') + \
                ('' if self.is_dummy else ' â€£ ' + self.description)

    # ==================================================================================================================
    # Stream (base class for Sink and Source)
    # ==================================================================================================================

    class Stream(GObject.GObject):
        """Base class for sink and source. Call it Stream to be consistent with Gnome Sound Panel."""

        def get_is_active(self):
            """is_active: defines whether the associated sink/source is the active (default) one."""
            return self._is_active

        def set_is_active(self, value: bool):
            self._is_active = value
            # If activated, also activate the item that corresponds to the active port
            if value:
                for port in self.ports.values():
                    if port.is_active:
                        port.is_active = True
                        break

        is_active = GObject.property(type=bool, default=False, getter=get_is_active, setter=set_is_active)

        def __init__(self, index: int, name: str, description: str, ports: dict, card_index: int):
            """Constructor."""
            GObject.GObject.__init__(self)
            self.index       = index
            self.name        = name
            self.description = description
            self.ports       = ports
            self.card_index  = card_index
            self._is_active  = False

            # Assign every port's owner_stream
            for port in self.ports.values():
                port.owner_stream = self

        # Activates the specified port by its name
        def activate_port_by_name(self, name: str):
            for port in self.ports.values():
                port.is_active = port.name == name

    # ==================================================================================================================
    # Source
    # ==================================================================================================================

    class Source(Stream):
        """Source class."""
        pass

    # ==================================================================================================================
    # Sink
    # ==================================================================================================================

    class Sink(Stream):
        """Sink class."""
        pass

    # ==================================================================================================================
    # CardProfile
    # ==================================================================================================================

    class CardProfile(GObject.GObject):
        """Card profile class."""

        def __init__(self, name: str, description: str, num_sinks: int, num_sources: int, priority: int, is_active: bool):
            """Constructor."""
            GObject.GObject.__init__(self)
            self.name        = name
            self.description = description
            self.num_sinks   = num_sinks
            self.num_sources = num_sources
            self.priority    = priority
            self.is_active   = is_active

    # ==================================================================================================================
    # Card
    # ==================================================================================================================

    class Card(GObject.GObject):
        """Card class."""

        @staticmethod
        def find_stream_port(card_port, sources: dict, sinks: dict):
            """Tries to find a sink/source port that corresponds to the given card port.
            :param card_port: Card port to find a matching port for
            :param sources: List of all sources to search in case the port is an input
            :param sinks: List of all sinks to search in case the port is an output
            :returns tuple containing stream (or None) and its port (or None)
            """
            found_stream = found_port = None
            # Try to find a sink/source for this card (by matching card index)
            streams = sinks if card_port.is_output else sources
            for stream in streams.values():
                if stream.card_index == card_port.owner_card.index:
                    found_stream = stream
                    # Found the stream. Try to find a corresponding stream's port (with the matching port name)
                    if card_port.name in stream.ports:
                        found_port = stream.ports[card_port.name]
                    break
            return found_stream, found_port

        def __init__(self, index: int, name: str, driver: str, profiles: dict, ports: dict, proplist):
            """Constructor."""
            GObject.GObject.__init__(self)
            self.index    = index
            self.name     = name
            self.driver   = driver
            self.profiles = profiles
            self.ports    = ports
            self.proplist = proplist

            # Initialise derived properties
            self.description = self.get_property_str("device.description")

            # Assign every port's owner_card
            for port in self.ports.values():
                port.owner_card = self

        def get_property_str(self, name: str) -> str:
            """Returns value of a property by its name as a string."""
            return pa_proplist_gets(self.proplist, name.encode()).decode()

        def update_port_activity(self, sources: dict, sinks: dict):
            """Updates the is_active state of every port on the card, according to the state of the related sink/source
            port, if any.
            """
            for port in self.ports.values():
                # Try to find a sink/source port for this port
                stream, stream_port = self.find_stream_port(port, sources, sinks)

                # Update the port object (this will also update the menu item). A port is active if it's mapped to an
                # active stream and is dummy or its corresponding stream's port is active
                port.is_active = \
                    stream is not None and \
                    stream.is_active and \
                    stream_port is not None and \
                    (port.is_dummy or stream_port.is_active)

    # ==================================================================================================================
    # SoundSwitcherIndicator's stuff
    # ==================================================================================================================

    def __init__(self):
        """Constructor."""
        GObject.GObject.__init__(self)

        # Create the indicator object
        self.ind = AppIndicator.Indicator.new(APP_ID, APP_ICON, AppIndicator.IndicatorCategory.HARDWARE)
        self.ind.set_status(AppIndicator.IndicatorStatus.ACTIVE)

        # Initialize PulseAudio object lists and references
        self.cards          = {}
        self.sources        = {}
        self.source_outputs = {}
        self.sinks          = {}
        self.sink_inputs    = {}
        self._pacb_card_info          = None
        self._pacb_context_notify     = None
        self._pacb_context_subscribe  = None
        self._pacb_context_success    = None
        self._pacb_server_info        = None
        self._pacb_sink_info          = None
        self._pacb_sink_input_info    = None
        self._pacb_source_info        = None
        self._pacb_source_output_info = None
        self.pa_context               = None
        self.pa_context_connected     = False
        self.pa_context_failed        = False

        # Create the menu
        self.item_header_inputs     = None
        self.item_separator_inputs  = None
        self.item_header_outputs    = None
        self.item_separator_outputs = None
        self.menu = Gtk.Menu()
        self.ind.set_menu(self.menu)
        self.menu_setup()

        # Initialize the PulseAudio interface
        self.pa_mainloop = None
        self.pa_mainloop_api = None
        if not self.pulseaudio_initialize():
            self.pulseaudio_shutdown()
            sys.exit(1)

    # ------------------------------------------------------------------------------------------------------------------
    # Signal handlers
    # ------------------------------------------------------------------------------------------------------------------

    def do_context_subscribe(self, facility: int, kind: int, index: int) -> bool:
        """Context status change handler. Always runs on the GUI thread."""
        logging.debug('.do_context_subscribe(facility: %d, kind: %d, index: %d)', facility, kind, index)

        # Dispatch the callback
        # -- Source
        if facility == PA_SUBSCRIPTION_EVENT_SOURCE:
            # Active port change events are fired as PA_SUBSCRIPTION_EVENT_CHANGE
            if kind == PA_SUBSCRIPTION_EVENT_NEW or kind == PA_SUBSCRIPTION_EVENT_CHANGE:
                self.synchronise_op(
                    pa_context_get_source_info_by_index(self.pa_context, index, self._pacb_source_info, None))
            elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
                self.source_remove(index)

        # -- Source output
        elif facility == PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
            if kind == PA_SUBSCRIPTION_EVENT_NEW:
                self.synchronise_op(
                    pa_context_get_source_output_info(self.pa_context, index, self._pacb_source_output_info, None))
            elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
                self.source_output_remove(index)

        # -- Sink
        elif facility == PA_SUBSCRIPTION_EVENT_SINK:
            # Active port change events are fired as PA_SUBSCRIPTION_EVENT_CHANGE
            if kind == PA_SUBSCRIPTION_EVENT_NEW or kind == PA_SUBSCRIPTION_EVENT_CHANGE:
                self.synchronise_op(
                    pa_context_get_sink_info_by_index(self.pa_context, index, self._pacb_sink_info, None))
            elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
                self.sink_remove(index)

        # -- Sink input
        elif facility == PA_SUBSCRIPTION_EVENT_SINK_INPUT:
            if kind == PA_SUBSCRIPTION_EVENT_NEW:
                self.synchronise_op(
                    pa_context_get_sink_input_info(self.pa_context, index, self._pacb_sink_input_info, None))
            elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
                self.sink_input_remove(index)

        # -- Card
        elif facility == PA_SUBSCRIPTION_EVENT_CARD:
            if kind == PA_SUBSCRIPTION_EVENT_NEW or kind == PA_SUBSCRIPTION_EVENT_CHANGE:
                self.synchronise_op(
                    pa_context_get_card_info_by_index(self.pa_context, index, self._pacb_card_info, None))
            elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
                self.card_remove(index)

        # -- Server
        elif facility == PA_SUBSCRIPTION_EVENT_SERVER:
            if kind == PA_SUBSCRIPTION_EVENT_CHANGE:
                self.synchronise_op(pa_context_get_server_info(self.pa_context, self._pacb_server_info, None))

        # Prevent this method from being called again
        return False

    def item_about(self, widget, buf):
        """Handler of about item click event."""
        logging.debug('.item_about()')
        dialog = Gtk.AboutDialog()
        dialog.set_program_name(APP_NAME)
        dialog.set_copyright('Written by Dmitry Kann')
        dialog.set_license(APP_LICENCE)
        dialog.set_version(APP_VERSION)
        dialog.set_website('http://yktoo.com')
        dialog.set_website_label('yktoo.com')
        dialog.set_logo_icon_name(APP_ICON)
        dialog.connect('response', lambda x, y: dialog.destroy())
        dialog.run()

    def item_quit(self, widget, buf):
        """Terminates the app."""
        logging.debug('.item_quit()')
        self.shutdown()

    def item_refresh(self, widget, buf):
        """Handler of refresh item click event."""
        logging.debug('.item_refresh()')
        self.update_all_pa_items()

    def item_select_port(self, widget, buf):
        """Handler of sink selection item click event."""
        if widget.get_active():
            # Fetch data from the buf tuple
            idx_card, port_name = buf

            # Find the card and its port
            card = self.cards[idx_card]
            port = card.ports[port_name]
            logging.info('# Card[%d], port `%s` selected', idx_card, port.name)

            # Try to find a matching stream and its port
            stream, stream_port = card.find_stream_port(port, self.sources, self.sinks)

            # If no stream found, that's an error
            if stream is None:
                logging.error('Failed to map card[%d], port `%s` to a stream', idx_card, port_name)
                return

            # If no matching port on that stream, we need to switch profile first
            if stream_port is None:
                self.card_switch_profile(port)

            # Switching output
            if port.is_output:
                # Change the default sink
                self.synchronise_op(
                    pa_context_set_default_sink(self.pa_context, stream.name.encode(), self._pacb_context_success, None))

                # Change the active port, if it's not a dummy one
                if not port.is_dummy:
                    pa_context_set_sink_port_by_index(
                        self.pa_context, stream.index, port.name.encode(), self._pacb_context_success, None)

                # Move all active sink inputs to the selected sink
                for idx in self.sink_inputs.keys():
                    self.synchronise_op(
                        pa_context_move_sink_input_by_index(
                            self.pa_context, idx, stream.index, self._pacb_context_success, None))

            # Switching input
            else:
                # Change the default source
                self.synchronise_op(
                    pa_context_set_default_source(
                        self.pa_context, stream.name.encode(), self._pacb_context_success, None))

                # Change the active port, if it's not a dummy one
                if not port.is_dummy:
                    pa_context_set_source_port_by_index(
                        self.pa_context, stream.index, port.name.encode(), self._pacb_context_success, None)

                # Move all active source outputs to the selected source
                for idx in self.source_outputs.keys():
                    self.synchronise_op(
                        pa_context_move_source_output_by_index(
                            self.pa_context, idx, stream.index, self._pacb_context_success, None))

    # ------------------------------------------------------------------------------------------------------------------
    # PulseAudio callbacks
    # ------------------------------------------------------------------------------------------------------------------

    def pacb_card_info(self, context, struct, eol, user_data):
        """Card callback."""
        if struct:
            # New card info arrived
            self.card_info(struct.contents)

        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    def pacb_context_notify(self, context, user_data):
        """Connection status callback."""
        ctxstate = pa_context_get_state(context)

        # Context connected and ready
        if ctxstate == PA_CONTEXT_READY:
            self.pa_context_connected = True
            logging.info('Context connected')

        # Context connection failed
        elif ctxstate == PA_CONTEXT_FAILED:
            self.pa_context_failed = True
            logging.critical('Context failed')

        # Context connection ended - end the mainloop
        elif ctxstate == PA_CONTEXT_TERMINATED:
            logging.info('Context terminated')

    def pacb_context_subscribe(self, context, event_type, index, user_data):
        """Context subscription callback."""
        facility = event_type & PA_SUBSCRIPTION_EVENT_FACILITY_MASK
        kind     = event_type & PA_SUBSCRIPTION_EVENT_TYPE_MASK

        # Pass the event on to the main GUI thread
        GObject.idle_add(self.do_context_subscribe, facility, kind, index)

        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    def pacb_context_success(self, context, c_int, user_data):
        """Context success callback."""
        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    def pacb_server_info(self, context, struct, user_data):
        """Server info callback."""
        if struct:
            self.activate_sink  (struct.contents.default_sink_name.decode())
            self.activate_source(struct.contents.default_source_name.decode())

        # Schedule a port status update on the main GUI thread
        GObject.idle_add(self.card_update_all_ports_activity)

        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    def pacb_sink_info(self, context, struct, index, user_data):
        """Sink info callback."""
        if struct:
            self.sink_info(struct.contents)

        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    def pacb_sink_input_info(self, context, struct, eol, user_data):
        """Sink input info callback."""
        if struct:
            # New sink input info arrived
            self.sink_input_add(struct.contents.index, struct.contents.name.decode(), struct.contents.sink)

        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    def pacb_source_info(self, context, struct, index, user_data):
        """Source info callback."""
        # Skip "sink monitor" sources
        if struct and (struct.contents.monitor_of_sink == PA_INVALID_INDEX):
            self.source_info(struct.contents)

        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    def pacb_source_output_info(self, context, struct, eol, user_data):
        """Source output info callback."""
        if struct:
            # New source output info arrived
            self.source_output_add(struct.contents.index, struct.contents.name.decode())

        # Wake up PA's thread
        pa_threaded_mainloop_signal(self.pa_mainloop, 0)

    # ------------------------------------------------------------------------------------------------------------------
    # Card list related procs
    # ------------------------------------------------------------------------------------------------------------------

    def card_fetch_profiles(self, num_profiles: int, pa_profiles: list, active_profile_name: str) -> dict:
        """Extracts card profiles from a PA data structure and returns them as a list of CardProfile objects."""
        profiles = {}
        idx = 0
        while idx < num_profiles:
            pa_profile = pa_profiles[idx]
            profile_name = pa_profile.name.decode()
            profiles[profile_name] = self.CardProfile(
                profile_name,
                pa_profile.description.decode(),
                pa_profile.n_sinks,
                pa_profile.n_sources,
                pa_profile.priority,
                profile_name == active_profile_name)
            idx += 1
        return profiles

    def card_fetch_ports(self, pa_ports: list) -> dict:
        """Extracts card ports from a PA data structure and returns them as a dict of Port objects, indexed by name."""
        ports = {}
        if pa_ports:
            idx = 0
            while True:
                port_ptr = pa_ports[idx]
                # NULL pointer terminates the array
                if not port_ptr:
                    break
                pa_port = port_ptr.contents
                port_name = pa_port.name.decode()
                ports[port_name] = self.Port(
                    port_name,
                    pa_port.description.decode(),
                    pa_port.priority,
                    pa_port.available != PA_PORT_AVAILABLE_NO,
                    pa_port.direction,
                    [pa_port.profiles[i].contents.name.decode() for i in range(0, pa_port.n_profiles)])
                idx += 1
        return ports

    def card_create_menu_items(self, card):
        """Inserts menu items for the given card."""
        for port in card.ports.values():
            # Create a menu item and save it in the port object
            port.menu_item = self.menu_insert_ordered_item(
                self.item_header_outputs    if port.is_output else self.item_header_inputs,
                self.item_separator_outputs if port.is_output else self.item_separator_inputs,
                port.get_menu_item_title(),
                port.is_available)
            # Bind a click handler
            port.handler_id = port.menu_item.connect('activate', self.item_select_port, (card.index, port.name))

    def card_info(self, data):
        """Registers new card object or updates an existing one."""
        # Fetch properties from the data struct
        index         = data.index
        name          = data.name.decode()
        act_prof_name = data.active_profile.contents.name.decode()

        # Prepare ports array
        card_ports = self.card_fetch_ports(data.ports)

        # If card already exists, fetch it
        if index in self.cards:
            logging.debug('  * Card[%d] updated', index)
            card = self.cards[index]

            # Update active profile
            for profile in card.profiles.values():
                profile.is_active = profile.name == act_prof_name
                if profile.is_active:
                    logging.debug('    * Activated profile: `%s` (`%s`)', profile.name, profile.description)

            # Update port availability
            for new_port in card_ports.values():
                if new_port.name in card.ports:
                    port = card.ports[new_port.name]
                    if port.is_available != new_port.is_available:
                        port.is_available = new_port.is_available
                        logging.debug(
                            '    * Port is made %savailable: `%s` (`%s`)',
                            '' if port.is_available else 'un', port.name, port.description)

        # Otherwise register a new card object
        else:
            logging.debug('  + Card[%d] added: `%s`', index, name)

            # Prepare profiles array
            card_profiles = self.card_fetch_profiles(data.n_profiles, data.profiles, act_prof_name)
            # Log profiles
            for profile in card_profiles.values():
                logging.debug(
                    '    + Card profile added: `%s` (`%s`), %d sinks, %d sources, priority: %d%s',
                    profile.name, profile.description, profile.num_sinks, profile.num_sources, profile.priority,
                    ' -- Active' if profile.is_active else '')
            # Log ports
            for port in card_ports.values():
                logging.debug(
                    '    + Card port added: `%s` (`%s`); priority: %d; direction: %d; available: %s',
                    port.name, port.description, port.priority, port.direction, YESNO[port.is_available])
                if port.profiles:
                    for port_profile_name in port.profiles:
                        logging.debug('      . Supported profile: `%s`', port_profile_name)

            # If there's no port on this card (most likely Bluetooth), create a couple of dummy ones
            if not card_ports:
                card_ports['#dummy_out'] = self.Port('#dummy_out', None, -1, True, PA_DIRECTION_OUTPUT, None)
                card_ports['#dummy_in']  = self.Port('#dummy_in',  None, -1, True, PA_DIRECTION_INPUT, None)

            # Create and register a new card object
            self.cards[index] = card = self.Card(
                index, name, data.driver.decode(), card_profiles, card_ports, data.proplist.contents)

            # Add a menu item for each card port
            self.card_create_menu_items(card)

    def card_remove(self, index: int):
        """Removes card object by its index (PulseAudio's card index)."""
        if index in self.cards:
            card = self.cards[index]
            logging.debug('  - Card[%d] removed: `%s`', index, card.name)

            # Remove all card ports' menu items
            for port in card.ports.values():
                if port.menu_item:
                    self.menu.remove(port.menu_item)

            # Remove the card object
            del self.cards[index]

    def card_remove_all(self):
        """Removes all cards."""
        for index in list(self.cards.keys()):
            self.card_remove(index)

    def card_update_all_ports_activity(self):
        """Updates the is_active state for ports on all cards."""
        for card in self.cards.values():
            card.update_port_activity(self.sources, self.sinks)

    def card_switch_profile(self, port):
        """Finds the most appropriate profile for the given card port and activates it on its card."""
        card = port.owner_card

        # Compile a list of profiles supporting the port
        profiles = {pname: card.profiles[pname] for pname in port.profiles if pname in card.profiles}

        # Pick the one with max priority
        max_prio_profile = max(profiles.values(), key=lambda k: k.priority)
        logging.debug(
            '* Switch card[%d] to profile `%s` with priority %d',
            card.index, max_prio_profile.name, max_prio_profile.priority)

        # Switch the profile
        self.synchronise_op(
            pa_context_set_card_profile_by_index(
                self.pa_context,
                card.index,
                max_prio_profile.name.encode(),
                self._pacb_context_success,
                None))

    # ------------------------------------------------------------------------------------------------------------------
    # Sink list related procs
    # ------------------------------------------------------------------------------------------------------------------

    def sink_info(self, data):
        """Registers new sink object or updates existing one."""
        # Fetch properties from the data struct
        index       = data.index
        name        = data.name.decode()
        description = data.description.decode()

        # If sink already exists, fetch it
        if index in self.sinks:
            logging.debug('  * Sink[%d] updated: `%s`, card %d', index, name, data.card)
            sink = self.sinks[index]

        # Otherwise register a new sink object
        else:
            logging.debug('  + Sink[%d] added: `%s`, card %d', index, name, data.card)

            # Prepare ports array: iterate through ports[] (array of pointers to structs)
            sink_ports = {}
            if data.ports:
                idx_port = 0
                while True:
                    port_ptr = data.ports[idx_port]
                    # NULL pointer terminates the array
                    if port_ptr:
                        port_struct = port_ptr.contents
                        port = self.Port(
                            port_struct.name.decode(),
                            port_struct.description.decode(),
                            port_struct.priority,
                            port_struct.available != PA_PORT_AVAILABLE_NO,
                            PA_DIRECTION_OUTPUT,
                            None)
                        sink_ports[port.name] = port
                        logging.debug(
                            '    + Sink port added: `%s` (`%s`); priority: %d; available: %s',
                            port.name, port.description, port.priority, YESNO[port.is_available])
                        idx_port += 1
                    else:
                        break

            # Create and register a new instance of Sink object
            sink = self.Sink(index, name, description, sink_ports, data.card)
            self.sinks[index] = sink

        # Update sink's active port, if there's any
        if data.active_port:
            port_name = data.active_port.contents.name.decode()
            logging.debug('    * Activated sink port `%s`', port_name)
            sink.activate_port_by_name(port_name)

            # Update all card ports
            self.card_update_all_ports_activity()

    def sink_remove(self, index: int):
        """Removes sink object by its index (PulseAudio's sink index)."""
        if index in self.sinks:
            sink = self.sinks[index]
            logging.debug('  - Sink[%d] removed: `%s`', index, sink.name)

            # Remove all sink ports' menu items
            for port in sink.ports.values():
                if port.menu_item:
                    self.menu.remove(port.menu_item)

            # Also remove the sink object from sinks[]
            del self.sinks[index]

    def sink_remove_all(self):
        """Removes all sink objects."""
        for index in list(self.sinks.keys()):
            self.sink_remove(index)

    # ------------------------------------------------------------------------------------------------------------------
    # Sink input list related procs
    # ------------------------------------------------------------------------------------------------------------------

    def sink_input_add(self, index: int, name: str, sink: int):
        """Registers new sink input object or updates an existing one."""
        # Remove existing sink input with the same index, if any
        self.sink_input_remove(index)
        logging.debug('  + Sink input[%d] added: `%s` -> sink %d', index, name, sink)

        # Register the new sink input
        self.sink_inputs[index] = name

    def sink_input_remove(self, index: int):
        """Removes sink input object by its index (PulseAudio's sink input index)."""
        if index in self.sink_inputs:
            logging.debug('  - Sink input[%d] removed: `%s`', index, self.sink_inputs[index])

            # Remove the sink input
            del self.sink_inputs[index]

    def sink_input_remove_all(self):
        """Removes all sink inputs."""
        for index in list(self.sink_inputs.keys()):
            self.sink_input_remove(index)

    # ------------------------------------------------------------------------------------------------------------------
    # Source list related procs
    # ------------------------------------------------------------------------------------------------------------------

    def source_info(self, data):
        """Registers new source object or updates existing one."""
        # Fetch properties from the data struct
        index       = data.index
        name        = data.name.decode()
        description = data.description.decode()

        # If source already exists, fetch it
        if index in self.sources:
            logging.debug('  * Source[%d] updated: `%s`, card %d', index, name, data.card)
            source = self.sources[index]

        # Otherwise register a new source object
        else:
            logging.debug('  + Source[%d] added: `%s`, card %d', index, name, data.card)
            # Prepare ports array: iterate through ports[] (array of pointers to structs)
            source_ports = {}
            if data.ports:
                idx_port = 0
                while True:
                    port_ptr = data.ports[idx_port]
                    # NULL pointer terminates the array
                    if port_ptr:
                        port_struct = port_ptr.contents
                        port = self.Port(
                            port_struct.name.decode(),
                            port_struct.description.decode(),
                            port_struct.priority,
                            port_struct.available != PA_PORT_AVAILABLE_NO,
                            PA_DIRECTION_INPUT,
                            None)
                        source_ports[port.name] = port
                        logging.debug(
                            '    + Source port added: `%s` (`%s`); priority: %d; available: %s',
                            port.name, port.description, port.priority, YESNO[port.is_available])
                        idx_port += 1
                    else:
                        break

            # Create and register a new instance of Source object
            source = self.Source(index, name, description, source_ports, data.card)
            self.sources[index] = source

        # Update source's active port, if there's any
        if data.active_port:
            port_name = data.active_port.contents.name.decode()
            logging.debug('    * Activated source port `%s`', port_name)
            source.activate_port_by_name(port_name)

            # Update all card ports
            self.card_update_all_ports_activity()

    def source_remove(self, index: int):
        """Removes source object by its index (PulseAudio's source index)."""
        if index in self.sources:
            source = self.sources[index]
            logging.debug('  - Source[%d] removed: `%s`', index, source.name)

            # Remove all source ports' menu items
            for port in source.ports.values():
                if port.menu_item:
                    self.menu.remove(port.menu_item)

            # Also remove the source object from sources[]
            del self.sources[index]

    def source_remove_all(self):
        """Removes all source objects."""
        for index in list(self.sources.keys()):
            self.source_remove(index)

    # ------------------------------------------------------------------------------------------------------------------
    # Source output list related procs
    # ------------------------------------------------------------------------------------------------------------------

    def source_output_add(self, index: int, name: str):
        """Registers new source output object or updates an existing one."""
        # Remove existing source output with the same index, if any
        self.source_output_remove(index)
        logging.debug('  + Source output[%d] added: `%s`', index, name)

        # Register the new source output
        self.source_outputs[index] = name

    def source_output_remove(self, index: int):
        """Removes source output object by its index (PulseAudio's source output index)."""
        if index in self.source_outputs:
            logging.debug('  - Source output[%d] removed: `%s`', index, self.source_outputs[index])

            # Remove the source output
            del self.source_outputs[index]

    def source_output_remove_all(self):
        """Removes all source outputs."""
        for index in list(self.source_outputs.keys()):
            self.source_output_remove(index)

    # ------------------------------------------------------------------------------------------------------------------
    # Other methods
    # ------------------------------------------------------------------------------------------------------------------

    def activate_sink(self, name: str):
        """Activates a sink by name."""
        logging.debug('* Activated sink: `%s`', name)
        for sink in self.sinks.values():
            sink.is_active = sink.name == name

    def activate_source(self, name: str):
        """Activates a source by name."""
        logging.debug('* Activated source: `%s`', name)
        for source in self.sources.values():
            source.is_active = source.name == name

    @staticmethod
    def main():
        """The main app function."""
        # Run the main event loop
        Gtk.main()

    def menu_append_item(self, label: str=None, activate_signal=None):
        """Adds an item (if label is None then separator item) to the indicator menu. Returns the created item."""
        if label is None:
            item = Gtk.SeparatorMenuItem()
        else:
            item = Gtk.MenuItem.new_with_mnemonic(label)
            if activate_signal is not None:
                item.connect("activate", activate_signal, None)
            else:
                item.set_sensitive(False)
        item.show()
        self.menu.append(item)
        return item

    def menu_insert_ordered_item(self, after_item, before_item, label: str, show: bool):
        """Inserts a new menu item into the menu between after_item and before_item, maintaining  alphabetical order of
        the items.

        :returns Created item.
        """
        # Indent the label a little
        label = "    " + label

        # Find out item indexes
        items = self.menu.get_children()
        idx_from = 0 if after_item is None else items.index(after_item) + 1
        idx_to   = items.index(before_item)

        # If there's at least one item, get the group from it
        group = [] if idx_to == idx_from else items[idx_from].get_group()

        # Create and setup a new radio item
        new_item = Gtk.RadioMenuItem.new_with_mnemonic(group, label)
        if show:
            new_item.show()

        # Find an appropriate position for the item so that they are in alphabetical order
        i = idx_from
        while (i < idx_to) and (label >= items[i].get_label()):
            i += 1

        # Insert the item
        self.menu.insert(new_item, i)
        return new_item

    def menu_setup(self):
        """Initializes indicator menu."""
        # Make the source list section
        self.item_header_inputs = self.menu_append_item('Inputs')
        self.item_separator_inputs = self.menu_append_item()

        # Make the sink list section
        self.item_header_outputs = self.menu_append_item('Outputs')
        self.item_separator_outputs = self.menu_append_item()

        # Add static items
        self.menu_append_item('_Refresh', self.item_refresh)
        self.menu_append_item('_About',   self.item_about)
        self.menu_append_item('_Quit',    self.item_quit)

    def pulseaudio_initialize(self):
        """PulseAudio initialization. Returns True if succeeded."""
        # Setup the callbacks
        self._pacb_card_info          = pa_card_info_cb_t         (self.pacb_card_info)
        self._pacb_context_notify     = pa_context_notify_cb_t    (self.pacb_context_notify)
        self._pacb_context_subscribe  = pa_context_subscribe_cb_t (self.pacb_context_subscribe)
        self._pacb_context_success    = pa_context_success_cb_t   (self.pacb_context_success)
        self._pacb_server_info        = pa_server_info_cb_t       (self.pacb_server_info)
        self._pacb_sink_info          = pa_sink_info_cb_t         (self.pacb_sink_info)
        self._pacb_sink_input_info    = pa_sink_input_info_cb_t   (self.pacb_sink_input_info)
        self._pacb_source_info        = pa_source_info_cb_t       (self.pacb_source_info)
        self._pacb_source_output_info = pa_source_output_info_cb_t(self.pacb_source_output_info)

        # Create PulseAudio's main loop
        self.pa_mainloop = pa_threaded_mainloop_new()
        self.pa_mainloop_api = pa_threaded_mainloop_get_api(self.pa_mainloop)

        # Create and connect PulseAudio context
        self.pa_context = pa_context_new(self.pa_mainloop_api, APP_NAME.encode())
        self.pa_context_connected = False
        self.pa_context_failed    = False
        pa_context_set_state_callback(self.pa_context, self._pacb_context_notify, None)
        pa_context_connect(self.pa_context, None, 0, None)

        # Start the main loop
        pa_threaded_mainloop_start(self.pa_mainloop)

        # Wait until the context is connected or failed
        while not (self.pa_context_connected or self.pa_context_failed):
            pass

        if self.pa_context_connected:
            # Update PulseAudio environment info
            self.update_all_pa_items()

            # Subscribe to context-specific daemon state changes
            self.synchronise_op(
                pa_context_subscribe(
                    self.pa_context,
                    PA_SUBSCRIPTION_MASK_CARD       |
                    PA_SUBSCRIPTION_MASK_SINK       |
                    PA_SUBSCRIPTION_MASK_SINK_INPUT |
                    PA_SUBSCRIPTION_MASK_SERVER     |
                    PA_SUBSCRIPTION_MASK_SOURCE     |
                    PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT,
                    self._pacb_context_success,
                    None))
            pa_context_set_subscribe_callback(self.pa_context, self._pacb_context_subscribe, None)
        return self.pa_context_connected

    def pulseaudio_shutdown(self):
        """PulseAudio shutdown."""
        # Disconnect and free the context
        if self.pa_context_connected:
            pa_context_disconnect(self.pa_context)
            self.pa_context_connected = False
        if self.pa_context is not None:
            pa_context_unref(self.pa_context)
            self.pa_context = None

        # Stop main loop thread
        if self.pa_mainloop is not None:
            pa_threaded_mainloop_stop(self.pa_mainloop)
            pa_threaded_mainloop_free(self.pa_mainloop)
            self.pa_mainloop = None

    def shutdown(self):
        """Shuts down the app."""
        self.pulseaudio_shutdown()
        Gtk.main_quit()

    def synchronise_op(self, operation):
        """Turns asynchronous PulseAudio operations into synchronous ones by waiting on the operation to complete.
        Finally unreferences the operation object.
        """
        # Lock the main loop. According to the official PA documentation this ought to happen before the operation is
        # created, but since we only have one worker thread (Gtk thread), no race for PA mainloop is expected and this
        # should do
        pa_threaded_mainloop_lock(self.pa_mainloop)

        # Wait on the operation
        while pa_operation_get_state(operation) == PA_OPERATION_RUNNING:
            pa_threaded_mainloop_wait(self.pa_mainloop)

        # Free the operation object
        pa_operation_unref(operation)

        # Unlock the main loop
        pa_threaded_mainloop_unlock(self.pa_mainloop)

    def update_all_pa_items(self):
        """Synchronously updates information about all PulseAudio items (sinks, sources, server etc.)."""
        # Remove all PA objects
        self.card_remove_all()
        self.source_remove_all()
        self.source_output_remove_all()
        self.sink_remove_all()
        self.sink_input_remove_all()

        # Cards
        self.synchronise_op(
            pa_context_get_card_info_list         (self.pa_context, self._pacb_card_info,          None))
        # Sources
        self.synchronise_op(
            pa_context_get_source_info_list       (self.pa_context, self._pacb_source_info,        None))
        # Source outputs
        self.synchronise_op(
            pa_context_get_source_output_info_list(self.pa_context, self._pacb_source_output_info, None))
        # Sinks
        self.synchronise_op(
            pa_context_get_sink_info_list         (self.pa_context, self._pacb_sink_info,          None))
        # Sink inputs
        self.synchronise_op(
            pa_context_get_sink_input_info_list   (self.pa_context, self._pacb_sink_input_info,    None))
        # Server info
        self.synchronise_op(
            pa_context_get_server_info            (self.pa_context, self._pacb_server_info,        None))

if __name__ == "__main__":

    # Parse the command line
    _parse_cmd_line()

    # Instantiate and run the indicator
    indicator = SoundSwitcherIndicator()
    indicator.main()
