#!/usr/bin/env python
### BEGIN LICENSE
# Copyright (C) 2012-2013 Dmitry Kann, http://yktoo.com
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3, as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

# Global definitions
APP_ID      = "indicator-sound-switcher"
APP_NAME    = "Sound Switcher Indicator"
APP_ICON    = "indicator-sound-switcher"
APP_VERSION = "1.2.0"
APP_LICENCE = '''This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3, as published
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranties of
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see http://www.gnu.org/licenses/'''

import sys
import threading

from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import AppIndicator3 as AppIndicator

from indicator_sound_switcher.lib_pulseaudio import *

class SoundSwitcherIndicator(object):

  #---------------------------------------------------------------------------------------------------------------------
  # Generic (sink/source) port class
  #---------------------------------------------------------------------------------------------------------------------

  class Port(object):

    # Constructor
    def __init__(self, name, description, priority):
      self.name        = name
      self.description = description
      self.priority    = priority
      self.is_active   = False
      self.menu_item   = None
      # Activate signal's handler ID (will be used for blocking the handler later)
      self.handler_id  = None

    # Activates the menu item that corresponds to the port, if any
    def activate_menu_item(self):
      if self.menu_item:
        # Disable triggering of the activate event
        with self.menu_item.handler_block(self.handler_id): self.menu_item.set_active(True)

  #---------------------------------------------------------------------------------------------------------------------
  # Base PulseAudio route class (sink/source)
  #---------------------------------------------------------------------------------------------------------------------

  class AudioRoute(object):

    # Constructor
    def __init__(self, index, name, description, ports):
      self.index       = index
      self.name        = name
      self.description = description
      self.ports       = ports
      self.is_active   = False

    # Activates the specified port. If b_activate_menu_item == True, also activates the corresponding menu item
    def activate_port(self, name, b_activate_menu_item):
      # Iterate through available ports to update their activity flags
      for port in self.ports.values(): port.is_active = port.name == name
      # Also activate the port's menu item if needed
      if b_activate_menu_item: self.activate_port_item()

    # Activates the item that corresponds to the active port
    def activate_port_item(self):
      if self.is_active:
        for port in self.ports.values():
          if port.is_active: port.activate_menu_item()

  #---------------------------------------------------------------------------------------------------------------------
  # Source class
  #---------------------------------------------------------------------------------------------------------------------

  class Source(AudioRoute):
    pass

  #---------------------------------------------------------------------------------------------------------------------
  # Sink class
  #---------------------------------------------------------------------------------------------------------------------

  class Sink(AudioRoute):
    pass

  #---------------------------------------------------------------------------------------------------------------------
  # Builtin overrides
  #---------------------------------------------------------------------------------------------------------------------

  # Constructor
  def __init__(self):
    global APP_ID, APP_ICON, APP_NAME
    # Create the indicator object
    self.ind = AppIndicator.Indicator.new(APP_ID, APP_ICON, AppIndicator.IndicatorCategory.HARDWARE)
    self.ind.set_status(AppIndicator.IndicatorStatus.ACTIVE)
    # Initialize PulseAudio object lists and references
    self.sources        = {}
    self.source_outputs = {}
    self.sinks          = {}
    self.sink_inputs    = {}
    # Create the menu
    self.item_separator_sources = None
    self.item_separator_sinks   = None
    self.menu = Gtk.Menu()
    self.ind.set_menu(self.menu)
    self.menu_setup()
    # Initialize the PulseAudio interface
    self.pa_mainloop = None
    self.pa_mainloop_api = None
    if not self.pulseaudio_initialize():
      self.pulseaudio_shutdown()
      sys.exit(1)

  #---------------------------------------------------------------------------------------------------------------------
  # Menu item handlers
  #---------------------------------------------------------------------------------------------------------------------

  # Handler of about item click event
  def item_about(self, widget, buf):
    global APP_NAME, APP_ICON, APP_VERSION, APP_LICENCE
    dialog = Gtk.AboutDialog()
    dialog.set_name(APP_NAME)
    dialog.set_copyright('Written by Dmitry Kann')
    dialog.set_license(APP_LICENCE)
    dialog.set_version(APP_VERSION)
    dialog.set_website('http://yktoo.com')
    dialog.set_website_label('yktoo.com')
    dialog.set_logo_icon_name(APP_ICON)
    dialog.connect("response", lambda x,y: dialog.destroy())
    dialog.run()

  # Terminates the app
  def item_quit(self, widget, buf):
    self.shutdown()

  # Handler of refresh item click event
  def item_refresh(self, widget, buf):
    self.update_all_pa_items()

  # Handler of sink selection item click event
  def item_select_sink(self, widget, buf):
    if widget.get_active():
      # Fetch indexes from the buf[] tuple
      idx_sink = buf[0]
      idx_port = buf[1]
      sink = self.sinks[idx_sink]
      self._log("Sink[{}].port[{}] selected".format(idx_sink, idx_port))
      # Change the default sink
      self.synchronise_op(pa_context_set_default_sink(self.pa_context, sink.name, self._pacb_context_success, None))
      # Change the active port
      pa_context_set_sink_port_by_index(self.pa_context, idx_sink, sink.ports[idx_port].name, self._pacb_context_success, None)
      # Move all active sink inputs to the selected sink
      for idx in self.sink_inputs.keys():
        self.synchronise_op(
          pa_context_move_sink_input_by_index(self.pa_context, idx, idx_sink, self._pacb_context_success, None))

  # Handler of source selection item click event
  def item_select_source(self, widget, buf):
    if widget.get_active():
      # Fetch indexes from the buf[] tuple
      idx_source = buf[0]
      idx_port   = buf[1]
      source = self.sources[idx_source]
      self._log("Source[{}].port[{}] selected".format(idx_source, idx_port))
      # Change the default source
      self.synchronise_op(pa_context_set_default_source(self.pa_context, source.name, self._pacb_context_success, None))
      # Change the active port
      pa_context_set_source_port_by_index(self.pa_context, idx_source, source.ports[idx_port].name, self._pacb_context_success, None)
      # Move all active source outputs to the selected source
      for idx in self.source_outputs.keys():
        self.synchronise_op(
          pa_context_move_source_output_by_index(self.pa_context, idx, source.index, self._pacb_context_success, None))

  #---------------------------------------------------------------------------------------------------------------------
  # PulseAudio callbacks
  #---------------------------------------------------------------------------------------------------------------------

  # Connection status callback
  def pacb_context_notify(self, context, user_data):
    ctxstate = pa_context_get_state(context)
    self._log(".pacb_context_notify(), state {}".format(ctxstate))
    # Context connected and ready
    if ctxstate == PA_CONTEXT_READY:
      self._log("Context connected")
      self.pa_context_connected = True
    # Context connection failed
    elif ctxstate == PA_CONTEXT_FAILED:
      self._log("Context failed")
      print "ERROR: PulseAudio connection failed"
      self.pa_context_failed = True
    # Context connection ended - end the mainloop
    elif ctxstate == PA_CONTEXT_TERMINATED:
      self._log("Context terminated")

  def pacb_context_subscribe(self, context, event_type, index, user_data):
    facility = event_type & PA_SUBSCRIPTION_EVENT_FACILITY_MASK
    kind     = event_type & PA_SUBSCRIPTION_EVENT_TYPE_MASK
    self._log(".pacb_context_subscribe(facility: {}, kind: {})".format(facility, kind))

    # Source
    if facility == PA_SUBSCRIPTION_EVENT_SOURCE:
      # Active port change events are fired as PA_SUBSCRIPTION_EVENT_CHANGE. user_data specifies whether menu item
      # activation is needed (False if a server update will follow)
      if kind == PA_SUBSCRIPTION_EVENT_NEW or kind == PA_SUBSCRIPTION_EVENT_CHANGE:
        pa_operation_unref(pa_context_get_source_info_by_index(self.pa_context, index, self._pacb_source_info, user_data))
      elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
        self.source_remove(index)

    # Source output
    elif facility == PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
      if kind == PA_SUBSCRIPTION_EVENT_NEW:
        pa_operation_unref(pa_context_get_source_output_info(self.pa_context, index, self._pacb_source_output_info, None))
      elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
        self.source_output_remove(index)

    # Sink
    if facility == PA_SUBSCRIPTION_EVENT_SINK:
      # Active port change events are fired as PA_SUBSCRIPTION_EVENT_CHANGE. user_data specifies whether menu item
      # activation is needed (False if a server update will follow)
      if kind == PA_SUBSCRIPTION_EVENT_NEW or kind == PA_SUBSCRIPTION_EVENT_CHANGE:
        pa_operation_unref(pa_context_get_sink_info_by_index(self.pa_context, index, self._pacb_sink_info, user_data))
      elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
        self.sink_remove(index)

    # Sink input
    elif facility == PA_SUBSCRIPTION_EVENT_SINK_INPUT:
      if kind == PA_SUBSCRIPTION_EVENT_NEW:
        pa_operation_unref(pa_context_get_sink_input_info(self.pa_context, index, self._pacb_sink_input_info, None))
      elif kind == PA_SUBSCRIPTION_EVENT_REMOVE:
        self.sink_input_remove(index)

    # Server
    elif facility == PA_SUBSCRIPTION_EVENT_SERVER:
      if kind == PA_SUBSCRIPTION_EVENT_CHANGE:
        pa_operation_unref(pa_context_get_server_info(self.pa_context, self._pacb_server_info, None))

  # Context success callback
  def pacb_context_success(self, context, c_int, user_data):
    pass

  def pacb_server_info(self, context, struct, user_data):
    if struct:
      self._log(".pacb_server_info()")
      self.activate_sink  (struct.contents.default_sink_name,   True)
      self.activate_source(struct.contents.default_source_name, True)

  def pacb_sink_info(self, context, struct, index, user_data):
    if struct:
      self._log(".pacb_sink_info({})".format(user_data))
      # User data is a flag that specifies whether menu item update is needed
      self.sink_info(
        struct.contents.index,
        struct.contents.name,
        struct.contents.description,
        struct.contents.ports,
        struct.contents.active_port,
        user_data)

  def pacb_sink_input_info(self, context, struct, eol, user_data):
    if struct:
      self._log(".pacb_sink_input_info()")
      # New sink input info arrived
      self.sink_input_add(struct.contents.index, struct.contents.name, struct.contents.sink)

  def pacb_source_info(self, context, struct, index, user_data):
    # Skip "sink monitor" sources
    if struct and (struct.contents.monitor_of_sink == PA_INVALID_INDEX):
      self._log(".pacb_source_info({})".format(user_data))
      # User data is a flag that specifies whether menu item update is needed
      self.source_info(
        struct.contents.index,
        struct.contents.name,
        struct.contents.description,
        struct.contents.ports,
        struct.contents.active_port,
        user_data)

  def pacb_source_output_info(self, context, struct, eol, user_data):
    if struct:
      self._log(".pacb_source_output_info()")
      # New source output info arrived
      self.source_output_add(struct.contents.index, struct.contents.name)

  #---------------------------------------------------------------------------------------------------------------------
  # Sink list related procs
  #---------------------------------------------------------------------------------------------------------------------

  # Registers new sink object or updates existing one
  def sink_info(self, index, name, description, ports, active_port, b_activate_menu_item):
    # If sink already exists, fetch it
    if index in self.sinks:
      self._log("    * Sink[{}] update: '{}'".format(index, name))
      sink = self.sinks[index]
    # Otherwise register a new sink object
    else:
      self._log("    + Sink[{}] addition: '{}'".format(index, name))
      # Prepare ports array: iterate through ports[] (array of pointers to structs)
      sink_ports = {}
      if ports:
        idx_port = 0
        while True:
          port_ptr = ports[idx_port]
          # NULL pointer terminates the array
          if port_ptr:
            port_struct = port_ptr.contents
            port = self.Port(port_struct.name, port_struct.description, port_struct.priority)
            sink_ports[idx_port] = port
            self._log("        + Sink port[{}] added: '{}'; '{}'; {}".format(idx_port, port_struct.name, port_struct.description, port_struct.priority))
            idx_port += 1
          else:
            break
      # Create and register a new instance of Sink object
      sink = self.Sink(index, name, description, sink_ports)
      self.sinks[index] = sink
      # Add a menu item for each sink port
      for idx_port in sink.ports.keys():
        port = sink.ports[idx_port]
        port.menu_item = self.menu_insert_ordered_item(self.item_header_sinks, self.item_separator_sinks, description + "/" + port.description)
        port.handler_id = port.menu_item.connect("activate", self.item_select_sink, (index, idx_port))
    # Update sink's active port
    sink.activate_port(active_port.contents.name, b_activate_menu_item)

  # Removes sink object by its index (PulseAudio's sink index)
  def sink_remove(self, index):
    if index in self.sinks:
      sink = self.sinks[index]
      self._log("    - Sink[{}] removed: '{}'".format(index, sink.name))
      # Remove all sink ports' menu items
      for port in sink.ports.values():
        if port.menu_item: self.menu.remove(port.menu_item)
      # Also remove the sink object from sinks[]
      del self.sinks[index]

  # Removes all sink objects
  def sink_remove_all(self):
    for index in self.sinks.keys(): self.sink_remove(index)

  #---------------------------------------------------------------------------------------------------------------------
  # Sink input list related procs
  #---------------------------------------------------------------------------------------------------------------------

  # Registers new sink input object or updates an existing one
  def sink_input_add(self, index, name, sink):
    # Remove existing sink input with the same index, if any
    self.sink_input_remove(index)
    self._log("    + Sink input[{}] added: '{}' -> sink {}".format(index, name, sink))
    # Register the new sink input
    self.sink_inputs[index] = name

  # Removes sink input object by its index (PulseAudio's sink input index)
  def sink_input_remove(self, index):
    if index in self.sink_inputs:
      self._log("    - Sink input[{}] removed: '{}'".format(index, self.sink_inputs[index]))
      # Remove the sink input
      del self.sink_inputs[index]

  # Removes all sink inputs
  def sink_input_remove_all(self):
    for index in self.sink_inputs.keys(): self.sink_input_remove(index)

  #---------------------------------------------------------------------------------------------------------------------
  # Source list related procs
  #---------------------------------------------------------------------------------------------------------------------

  # Registers new source object or updates existing one
  def source_info(self, index, name, description, ports, active_port, b_activate_menu_item):
    # If source already exists, fetch it
    if index in self.sources:
      self._log("    * Source[{}] update: '{}'".format(index, name))
      source = self.sources[index]
    # Otherwise register a new source object
    else:
      self._log("    + Source[{}] addition: '{}'".format(index, name))
      # Prepare ports array: iterate through ports[] (array of pointers to structs)
      source_ports = {}
      if ports:
        idx_port = 0
        while True:
          port_ptr = ports[idx_port]
          # NULL pointer terminates the array
          if port_ptr:
            port_struct = port_ptr.contents
            port = self.Port(port_struct.name, port_struct.description, port_struct.priority)
            source_ports[idx_port] = port
            self._log("        + Source port[{}] added: '{}'; '{}'; {}".format(idx_port, port_struct.name, port_struct.description, port_struct.priority))
            idx_port += 1
          else:
            break
      # Create and register a new instance of Source object
      source = self.Source(index, name, description, source_ports)
      self.sources[index] = source
      # Add a menu item for each source port
      for idx_port in source.ports.keys():
        port = source.ports[idx_port]
        port.menu_item = self.menu_insert_ordered_item(self.item_header_sources, self.item_separator_sources, description + "/" + port.description)
        port.handler_id = port.menu_item.connect("activate", self.item_select_source, (index, idx_port))
    # Update source's active port
    source.activate_port(active_port.contents.name, b_activate_menu_item)

  # Removes source object by its index (PulseAudio's source index)
  def source_remove(self, index):
    if index in self.sources:
      source = self.sources[index]
      self._log("    - Source[{}] removed: '{}'".format(index, source.name))
      # Remove all source ports' menu items
      for port in source.ports.values():
        if port.menu_item: self.menu.remove(port.menu_item)
      # Also remove the source object from sources[]
      del self.sources[index]

  # Removes all source objects
  def source_remove_all(self):
    for index in self.sources.keys(): self.source_remove(index)

  #---------------------------------------------------------------------------------------------------------------------
  # Source output list related procs
  #---------------------------------------------------------------------------------------------------------------------

  # Registers new source output object or updates an existing one
  def source_output_add(self, index, name):
    # Remove existing source output with the same index, if any
    self.source_output_remove(index)
    self._log("    + Source output[{}] added: '{}'".format(index, name))
    # Register the new source output
    self.source_outputs[index] = name

  # Removes source output object by its index (PulseAudio's source output index)
  def source_output_remove(self, index):
    if index in self.source_outputs:
      self._log("    - Source output[{}] removed: '{}'".format(index, self.source_outputs[index]))
      # Remove the source output
      del self.source_outputs[index]

  # Removes all source outputs
  def source_output_remove_all(self):
    for index in self.source_outputs.keys(): self.source_output_remove(index)

  #---------------------------------------------------------------------------------------------------------------------
  # Other methods
  #---------------------------------------------------------------------------------------------------------------------

  # Debug output method
  def _log(self, msg):
    print msg #!!!
    return

  # Activates the sink with the specified name. If b_activate_menu_item == True, also updates active port's menu item
  def activate_sink(self, name, b_activate_menu_item):
    for sink in self.sinks.values():
      sink.is_active = sink.name == name
      if b_activate_menu_item and sink.is_active: sink.activate_port_item()

  # Activates the source with the specified name. If b_activate_menu_item == True, also updates active port's menu item
  def activate_source(self, name, b_activate_menu_item):
    for source in self.sources.values():
      source.is_active = source.name == name
      if b_activate_menu_item and source.is_active: source.activate_port_item()

  # Main event loop
  def main(self):
    # GTK's main loop has to be thread safe and allow GIL to be lifted for other threads to run
    Gdk.threads_init()
    Gtk.main()

  # Adds an item (if label is None then separator item) to the indicator menu. Returns the created item
  def menu_append_item(self, label=None, activate_signal=None):
    if label is None:
      item = Gtk.SeparatorMenuItem()
    else:
      item = Gtk.MenuItem.new_with_mnemonic(label)
      if activate_signal is not None:
        item.connect("activate", activate_signal, None)
      else:
        item.set_sensitive(False)
    item.show()
    self.menu.append(item)
    return item

  # Inserts a new menu item into the menu between after_item and before_item, maintaining  alphabetical order of the
  # items. Returns the created item
  def menu_insert_ordered_item(self, after_item, before_item, label):
    # Indent the label a little
    label = "    " + label
    # Find out item indexes
    items = self.menu.get_children()
    idx_from = 0 if after_item is None else items.index(after_item)+1
    idx_to   = items.index(before_item)
    # If there's at least one item, get the group from it
    group = [] if idx_to == idx_from else items[idx_from].get_group()
    # Create and setup a new radio item
    new_item = Gtk.RadioMenuItem.new_with_mnemonic(group, label)
    new_item.show()
    # Find an appropriate position for the item so that they are in alphabetical order
    i = idx_from
    while (i < idx_to) and (label >= items[i].get_label()): i += 1
    # Insert the item
    self.menu.insert(new_item, i)
    return new_item

  # Initializes indicator menu
  def menu_setup(self):
    # Make the source list section
    self.item_header_sources = self.menu_append_item('Inputs')
    self.item_separator_sources = self.menu_append_item()
    # Make the sink list section
    self.item_header_sinks = self.menu_append_item('Outputs')
    self.item_separator_sinks = self.menu_append_item()
    # Add static items
    self.menu_append_item('_Refresh device list',   self.item_refresh)
    self.menu_append_item('_About',                 self.item_about)
    self.menu_append_item('_Quit',                  self.item_quit)

  # PulseAudio initialization. Returns True if succeeded
  def pulseaudio_initialize(self):
    # Setup the callbacks
    self._pacb_context_notify     = pa_context_notify_cb_t    (self.pacb_context_notify)
    self._pacb_context_subscribe  = pa_context_subscribe_cb_t (self.pacb_context_subscribe)
    self._pacb_context_success    = pa_context_success_cb_t   (self.pacb_context_success)
    self._pacb_server_info        = pa_server_info_cb_t       (self.pacb_server_info)
    self._pacb_sink_info          = pa_sink_info_cb_t         (self.pacb_sink_info)
    self._pacb_sink_input_info    = pa_sink_input_info_cb_t   (self.pacb_sink_input_info)
    self._pacb_source_info        = pa_source_info_cb_t       (self.pacb_source_info)
    self._pacb_source_output_info = pa_source_output_info_cb_t(self.pacb_source_output_info)
    # Create PulseAudio's main loop
    self.pa_mainloop = pa_threaded_mainloop_new()
    self.pa_mainloop_api = pa_threaded_mainloop_get_api(self.pa_mainloop)
    # Create and connect PulseAudio context
    self.pa_context = pa_context_new(self.pa_mainloop_api, APP_NAME)
    self.pa_context_connected = False
    self.pa_context_failed    = False
    pa_context_set_state_callback(self.pa_context, self._pacb_context_notify, None)
    pa_context_connect(self.pa_context, None, 0, None)
    # Start the main loop
    pa_threaded_mainloop_start(self.pa_mainloop)
    # Wait until the context is connected or failed
    while not (self.pa_context_connected or self.pa_context_failed): pass
    if self.pa_context_connected:
      # Update PulseAudio environment info
      self.update_all_pa_items()
      # Subscribe to context-specific daemon state changes
      self.synchronise_op(
        pa_context_subscribe(
          self.pa_context,
          PA_SUBSCRIPTION_MASK_SINK | PA_SUBSCRIPTION_MASK_SINK_INPUT | PA_SUBSCRIPTION_MASK_SERVER  |
            PA_SUBSCRIPTION_MASK_SOURCE | PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT,
          self._pacb_context_success,
          None))
      pa_context_set_subscribe_callback(self.pa_context, self._pacb_context_subscribe, None);
    return self.pa_context_connected

  # PulseAudio shutdown
  def pulseaudio_shutdown(self):
    # Disconnect and free the context
    if self.pa_context_connected:
      pa_context_disconnect(self.pa_context)
      self.pa_context_connected = False
    if self.pa_context is not None:
      pa_context_unref(self.pa_context)
      self.pa_context = None
    # Stop main loop thread
    if self.pa_mainloop is not None:
      pa_threaded_mainloop_stop(self.pa_mainloop)
      pa_threaded_mainloop_free(self.pa_mainloop)
      self.pa_mainloop = None

  # Shuts down the app
  def shutdown(self):
    self.pulseaudio_shutdown()
    Gtk.main_quit()

  # Turns asynchronous PulseAudio operations into synchronous ones by waiting on the operation to complete.
  # Finally unreferences the operation object
  def synchronise_op(self, operation):
    while pa_operation_get_state(operation) == PA_OPERATION_RUNNING:
      pass
    pa_operation_unref(operation)

  # Synchronously updates information about all PulseAudio items (sinks, sources, server etc.)
  def update_all_pa_items(self):
    self._log(".update_all_pa_items()")
    # Remove all PA objects
    self.source_remove_all()
    self.source_output_remove_all()
    self.sink_remove_all()
    self.sink_input_remove_all()
    # Sources
    self.synchronise_op(pa_context_get_source_info_list       (self.pa_context, self._pacb_source_info,        False))
    # Source outputs
    self.synchronise_op(pa_context_get_source_output_info_list(self.pa_context, self._pacb_source_output_info, None))
    # Sinks
    self.synchronise_op(pa_context_get_sink_info_list         (self.pa_context, self._pacb_sink_info,          False))
    # Sink inputs
    self.synchronise_op(pa_context_get_sink_input_info_list   (self.pa_context, self._pacb_sink_input_info,    None))
    # Server info
    self.synchronise_op(pa_context_get_server_info            (self.pa_context, self._pacb_server_info,        None))

if __name__ == "__main__":
  indicator = SoundSwitcherIndicator()
  indicator.main()
